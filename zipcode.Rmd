---
title: "Social Proximity Zipcode"
author: 
date: 
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Social Networks can be a significant factor in understanding the dynamics of various aspects of different fields such as social,economical and public health. In order to substanitate the intensity of social network between individuals Bailey et al proposed a relative frequency of Friendship links between different geographical unit called as Social Connectedness Index. Due to the nature of its relative frequency a comparision between the intensity of social ties across different locations can now be possible. Further Kulcher et al proposed another measure understanding the social influence of alters on ego called social proximity. This markdown file is a guide for other researchers who would want to make use of Social Proximity in there research.

```{r}
library(tidyverse)
library(igraph)
```

We create the social proximity values for each zipcode beginning with a 1. We then drop zipcodes that fall outside of Pennsylvania. As a first step we want to convert the SCI values into relative probabilities so we divide the SCI by the highest frequency of SCI and create a data frame with user location fr_locations and their probability values.

```{r}
#df_0 <- read_tsv ('zcta_zcta_shard1.tsv')
df_0 <- df_0 %>% dplyr::mutate(probabilites=scaled_sci/(1000000000)) 
df_1 <- df_0 %>% dplyr::filter(user_loc %in% 15001:19612 & fr_loc %in% 15001:19612)
df_1 <- unique(df_1)
df_1 <- df_1 %>% distinct(probabilites,.keep_all = TRUE) ##single repeated pairwise comparisons for sci
user_loc <- df_1 %>% distinct(user_loc)
```

Add zipcode information
```{r}
library(zipcodeR)
user_loc
distance_list <- c()
for (i in 1: length(df_1$user_loc)){
   distance_list <-c(distance_list, zip_distance(df_1$user_loc[i], df_1$fr_loc[i]))
}
df_1$distance <- distance_list
```

Further to create a weighted probabilities scaled by SCI and the weights of friend location we create a new data frame and mutate it with weighted SCI. 
```{r}
df_s <- merge(df_1,q_i,by="fr_loc")
df_s <- df_s %>% mutate(wt_sci=probabilites*wt)
df_s <- df_s[,c(2,1,3,4,5)]
```

First create an adjacency matrix between user_loc and friendship_loc with probabilities as their entries. Further we make all the diagonal matrix 0. 

```{r}
dataframe_for_matrix <- df_1 %>% dplyr::select(c(user_loc,fr_loc,probabilites))
nodes <- df_1 %>% distinct(user_loc)
g <- graph.data.frame(dataframe_for_matrix, directed=F, vertices=nodes)
sci_proximity <- as_adjacency_matrix(g,attr = "probabilites",sparse = F)
diag(sci_proximity) <- 0
```

The following chunk constructs our denominator.
```{R}
df_for_matrix_probability <- df_s %>% dplyr::select(c(user_loc,fr_loc,probabilites))
df_for_matrix_probability
k <- graph.data.frame(df_for_matrix_probability, directed=F, vertices=nodes)
cumulative_sci <- as_adjacency_matrix(k,attr="probabilites",sparse=F)
row_wise_sum_sci <- rowSums(cumulative_sci)
row_wise_sum_sci
```

Here 2 signifies column wise division. Sci_proximity for each county
```{r}
sci_proximity <- sweep(sci_proximity,2,row_wise_sum_sci,FUN="/")
sci_proximity_county <- rowSums(sci_proximity)
sci_proximity_county
```

```{r}
library(reshape)
sci_county_pairs <- melt(sci_proximity_county)[melt(upper.tri(sci_proximity_county))$value,]#this transposes the upper triangle of your table into three columns: a column from the header row, the first column containing the species names and then the third contains the distances
names(sci_county_pairs) <- c("County 1", "County 2", "sci") #this adds header row 
sci_county_pairs
```

```{r}
matrix <- as.matrix(sci_proximity_county)
sci_proximity_county %>% pivot_longer(cols = c('42001', '42003'), names_to = "Code", values_to = 'SCI')
```

